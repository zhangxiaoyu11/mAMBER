#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
CPPTRAJ Development Notes
\end_layout

\begin_layout Author
Daniel R.
 Roe
\begin_inset Newline newline
\end_inset

Jason M.
 Swails (Code Docs)
\end_layout

\begin_layout Date
2010-07-21
\begin_inset Newline newline
\end_inset

2012-08-13
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Abstract
CPPTRAJ is code intended to be a complement and perhaps eventually a replacement
 for PTRAJ, the MD trajectory analysis software that comes packaged with
 AmberTools.
 CPPTRAJ is a complete rewrite of the PTRAJ code in C++, the intent being
 to make the code more readable, leak-free, and thread-safe.
 The biggest functional change from PTRAJ is the ability to load and process
 trajectories with different topology files in the same run.
\end_layout

\begin_layout Abstract
This guide assumes that the reader has at least a basic familiarity with
 C++/object-oriented programming.
 If you aren't sure what a constructor is you may have a difficult time
 coding in Cpptraj.
 There are several good introduction to C++ tutorials on the web that may
 be helpful.
 
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Abstract
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
Introduction
\begin_inset CommandInset label
LatexCommand label
name "part:Coding-Conventions"

\end_inset


\end_layout

\begin_layout Section
Coding Conventions
\end_layout

\begin_layout Standard
It is important to maintain a consistent coding style within cpptraj so
 that it remains easy to modify and understand.
 By following code conventions, it will be easier to read code written by
 anybody and determine what is happening.
\end_layout

\begin_layout Itemize
Code blocks are indented using 2 spaces.
\end_layout

\begin_layout Itemize
Class types are named using 
\emph on
CapWords
\emph default
 (no spaces or underscores, start of each word is a capital letter).
\end_layout

\begin_layout Itemize
C++ files have '.cpp' suffix, C files have '.c' suffix, header files have
 '.h' suffix.
\end_layout

\begin_layout Itemize
All header files should have a '#define' guard to prevent multiple inclusion.
 The define guard has format:
\end_layout

\begin_layout LyX-Code
#ifndef INC_<basefilename>_H
\end_layout

\begin_layout LyX-Code
#define INC_<basefilename>_H
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
#endif
\end_layout

\begin_layout Itemize
The order of #include directives should be (in general): C includes, C++
 includes, class definition, any other Cpptraj includes.
\end_layout

\begin_layout Itemize
Files containing a class should be named after the class (e.g.
 'class TrajectoryFile {};' in TrajectoryFile.cpp).
\end_layout

\begin_layout Itemize
Classes which inherit should be named after their base class (e.g.
 'class Action_Distance : public Action { };').
\end_layout

\begin_layout Itemize
Class methods are named using 
\emph on
CapWords
\emph default
.
\end_layout

\begin_layout Itemize
Public methods should be listed first; protected methods/variables second;
 private methods/variables last.
\end_layout

\begin_layout Itemize
All class member variables should be private.
\end_layout

\begin_layout Itemize
Abbreviations: 1st letter in each word is capitalized.
 For instance, 
\family typewriter
Data File List
\family default
 may be abbreviated 
\family typewriter
DatFilList
\family default
 or 
\family typewriter
DFL.
\end_layout

\begin_layout Itemize
Variables that have function scope (or lower) and all public variables for
 classes are named using 
\emph on
mixedCase
\emph default
 (same as 
\emph on
CapWords
\emph default
 except the first letter is lower-case).
\end_layout

\begin_layout Itemize
Class variables that are 
\family typewriter
private
\family default
 or 
\family typewriter
protected
\family default
 are named using 
\emph on
mixedCase_
\emph default
 (with a trailing underscore).
\end_layout

\begin_layout Itemize
No one-letter variable names except in loop scopes (e.g.
 for (int i = 0; i < N; ++i) { } ).
\end_layout

\begin_layout Itemize
All identifiers in an enumerated type are all caps, and the first identifier
 should be explicitly initialized (e.g.
 enum DirectionType { DX = 0, DY, DZ };).
\end_layout

\begin_layout Itemize
There is a 
\emph on
doxygen
\emph default
 rule file to automatically generate code documentation using 
\emph on
doxygen
\emph default
, so please construct comments in such a doxygen-compatible manner (e.g.
 JavaDoc etc).
 See http://www.stack.nl/~dimitri/doxygen/manual.html for instructions.
\end_layout

\begin_layout Itemize
Use of STL classes/methods is acceptable; use C99 conventions to maximize
 portability.
\end_layout

\begin_layout Itemize
The only external libraries that should be used are NetCDF and ARPACK/LAPACK/BLA
S (both included with AmberTools), i.e.
 no Boost etc.
\end_layout

\begin_layout Section
Building Cpptraj and Documentation
\end_layout

\begin_layout Standard
Cpptraj is built alongside AmberTools, or it can be built standalone using
 the configure script in the 
\family typewriter
$AMBERHOME/AmberTools/src/cpptraj
\family default
 directory.
 Type './configure --help' for a list of standalone configure options.
 In order to build Cpptraj standalone one needs to specify the location
 of the NetCDF, zlib, and bzlib2 libraries if they aren't in your system
 path; otherwise specify a -noX option to disable use of that library.
 Also, currently for certain functions Cpptraj needs access to the BLAS,
 LAPACK, and ARPACK libraries bundled with AMBER, so either AMBERHOME must
 be set or 
\begin_inset Quotes eld
\end_inset

-nomathlib
\begin_inset Quotes erd
\end_inset

 specified to disable this functionality.
 If AMBERHOME is set and NetCDF/BLAS/LAPACK/ARPACK are already built, specify
 the '-amberlib' flag to automatically use the these libraries from AMBERHOME.
\end_layout

\begin_layout Standard
To build cpptraj standalone:
\end_layout

\begin_layout LyX-Code
./configure [options]
\end_layout

\begin_layout LyX-Code
make install_local OR cd src && make install
\end_layout

\begin_layout Standard
To build the documentation using 
\emph on
doxygen
\emph default
, you must have 
\emph on
doxygen
\emph default
 installed, and you must have configured AmberTools.
 Run the command:
\end_layout

\begin_layout LyX-Code
make docs
\end_layout

\begin_layout Standard
to build the documentation.
 PDF files and HTML files are generated during this process, showing class
 inheritance and descriptions from comments written in doxy-format.
 Open the file 
\family typewriter
$AMBERHOME/AmberTools/src/cpptraj/doc/html/index.html
\family default
 to see the class heirarchy and descriptions.
\end_layout

\begin_layout Section
Brief Overview of Key Classes
\end_layout

\begin_layout Standard
The following is a brief list of some of the more commonly-used classes
 in Cpptraj.
 Classes are more or less self-documented to a certain extent; this section
 will be focused on how these classes are/should be used.
\end_layout

\begin_layout Subsection
ArgList
\end_layout

\begin_layout Standard
The ArgList class is used throughout Cpptraj.
 It is the main way that user input is translated to actions, analyses,
 trajectory IO, etc.
 Basically, the ArgList class takes a string and separates it into tokens
 based on a given delimiter or delimiters.
 For example, the user input:
\end_layout

\begin_layout LyX-Code
trajin mytraj.nc 1 100 10
\end_layout

\begin_layout Standard
can be separated via a space (' ') delimeter into 5 tokens:
\end_layout

\begin_layout LyX-Code
0: trajin
\end_layout

\begin_layout LyX-Code
1: mytraj.nc
\end_layout

\begin_layout LyX-Code
2: 1
\end_layout

\begin_layout LyX-Code
3: 100
\end_layout

\begin_layout LyX-Code
4: 10
\end_layout

\begin_layout Standard
Similarly, the user input:
\end_layout

\begin_layout LyX-Code
d01,d02,d03,d04
\end_layout

\begin_layout Standard
can be separated via a comma (',') delimiter into 4 tokens:
\end_layout

\begin_layout LyX-Code
0: d01
\end_layout

\begin_layout LyX-Code
1: d02
\end_layout

\begin_layout LyX-Code
2: d03
\end_layout

\begin_layout LyX-Code
3: d04
\end_layout

\begin_layout Standard
These tokens (or arguments) are stored internally as an STL vector of strings.
 ArgList provides many functions to access user arguments.
 A second array of boolean values records whether an argument has been accessed.
 This concept is functionally similar to the argumentStack in Ptraj; however,
 it avoids the constant memory allocation/deallocation when arguments are
 added/accessed, and allows an argument list to be re-used if desired.
 The two main ways arguments are usually accessed are through 
\begin_inset Quotes eld
\end_inset

GetNext
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

GetKey
\begin_inset Quotes erd
\end_inset

 functions.
 
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

GetNext
\begin_inset Quotes erd
\end_inset

 functions return the next argument of the desired type.
 For example, using the ArgList created in the first example from 
\begin_inset Quotes eld
\end_inset

trajin mytraj.nc 1 100 10
\begin_inset Quotes erd
\end_inset

 and assuming all arguments are unmarked, GetStringNext() would return 
\begin_inset Quotes eld
\end_inset

trajin
\begin_inset Quotes erd
\end_inset

, while getNextInteger() would return 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

; in both cases the argument returned would be marked, so that a subsequent
 call to GetStringNext() would return 
\begin_inset Quotes eld
\end_inset

mytraj.nc
\begin_inset Quotes erd
\end_inset

 and so on.
 Another very commonly used 
\begin_inset Quotes eld
\end_inset

GetNext
\begin_inset Quotes erd
\end_inset

 function is the 
\begin_inset Quotes eld
\end_inset

GetMaskNext()
\begin_inset Quotes erd
\end_inset

 function, which returns the next atom mask expression (so noted because
 it will begin with ':', '@', '*'); an example of this will be shown below.
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

GetKey
\begin_inset Quotes erd
\end_inset

 functions return an argument next to a specified 
\begin_inset Quotes eld
\end_inset

key
\begin_inset Quotes erd
\end_inset

 string.
 Take for example the argument list created from 
\begin_inset Quotes eld
\end_inset

rmsd R1 @CA ref [myref] out rmsd.dat
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout LyX-Code
0: rmsd
\end_layout

\begin_layout LyX-Code
1: R1
\end_layout

\begin_layout LyX-Code
2: @CA
\end_layout

\begin_layout LyX-Code
2: ref
\end_layout

\begin_layout LyX-Code
3: [myref]
\end_layout

\begin_layout LyX-Code
4: out
\end_layout

\begin_layout LyX-Code
5: rmsd.dat
\end_layout

\begin_layout Standard
If we want to access a specific argument, we use a 
\begin_inset Quotes eld
\end_inset

GetKey
\begin_inset Quotes erd
\end_inset

 function.
 For example, if we want to know the filename specified by 'out', we would
 use GetStringKey(
\begin_inset Quotes eld
\end_inset

out
\begin_inset Quotes erd
\end_inset

); this would return 
\begin_inset Quotes eld
\end_inset

rmsd.dat
\begin_inset Quotes erd
\end_inset

, and mark both 
\begin_inset Quotes eld
\end_inset

out
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

rmsd.dat
\begin_inset Quotes erd
\end_inset

.
 Similarly, GetStringKey(
\begin_inset Quotes eld
\end_inset

ref
\begin_inset Quotes erd
\end_inset

) would return 
\begin_inset Quotes eld
\end_inset

[myref]
\begin_inset Quotes erd
\end_inset

.
 At this point we could also use the GetMaskNext() function to get the atom
 mask expression 
\begin_inset Quotes eld
\end_inset

@CA
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
AtomMask
\end_layout

\begin_layout Standard
The AtomMask class is another important class.
 It keeps track of what atoms in a given coordinate Frame are selected based
 on a given mask expression.
 Unlike Ptraj, in Cpptraj the AtomMask functions in 2 ways.
 The main way to use AtomMask is as an integer mask, where the atom numbers
 currently selected are stored as an array of integers.
 The second way (useful when one needs to know both selected and unselected
 atoms) is to use AtomMask as a character mask, which is analogous to the
 way masks functions in Ptraj.
 However, most of the AtomMask functionality requires it to be set up as
 a character mask, and all of the interfacing with Frame and Topology require
 this; in the interests of speed this is NOT EXPLICITLY CHECKED so it is
 up to the developer to use AtomMask responsibly.
\end_layout

\begin_layout Standard
There are 3 phases to using AtomMask: 1) initialization with a mask expression,
 2) setup via a Topology class, and 3) iteration over the mask.
 Initialization with a mask expression performs all necessary tokenization
 of the mask expression string and prepares the mask to be set up, but does
 not actually select atoms.
 The mask expression can be used during AtomMask construction or passed
 in via SetMaskString():
\end_layout

\begin_layout LyX-Code
Mask = new AtomMask(
\begin_inset Quotes eld
\end_inset

@CA
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout LyX-Code
Mask.SetMaskString(
\begin_inset Quotes eld
\end_inset

@CA
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Standard
Setup occurs via a Topology class (since in order to set up a mask you need
 to know atom names/numbers, residue name/number/types etc).
 This can be done using SetupIntegerMask() or SetupCharMask() to set up
 an integer mask (more common) or a char mask:
\end_layout

\begin_layout LyX-Code
Top.SetupIntegerMask( Mask );
\end_layout

\begin_layout LyX-Code
Top.SetupCharMask( Mask );
\end_layout

\begin_layout Standard
If necessary, one can convert between the mask types post-setup by the AtomMask
 ConvertMaskType() function.
 Once a mask has been setup the Nselected() function returns the number
 of selected atoms, while the None() function returns true if no atoms were
 selected.
\end_layout

\begin_layout Standard
The final stage is to make use of the atom mask.
 Many functions in the Frame class take an integer AtomMask as input.
 One can iterate over selected atoms in an integer atom mask using the STL-like
 const_iterator variable and begin() and end() functions - this is the recommend
ed way to use atom masks:
\end_layout

\begin_layout LyX-Code
for (AtomMask::const_iterator atomnum = Mask.begin(); atomnum != Mask.end();
 ++atomnum)
\end_layout

\begin_layout Standard
One can also access members of the integer array directly via the bracket
 ('[]') operator:
\end_layout

\begin_layout LyX-Code
for (int maskidx = 0; maskidx < Mask.Nselected(); ++maskidx)
\end_layout

\begin_layout LyX-Code
  int atomnum = Mask[atomidx];
\end_layout

\begin_layout Standard
In order to access an AtomMask that has been set up as a char mask, use
 the AtomInCharMask() and AtomsInCharMask() functions.
 The former returns true if a specified atom is selected, the latter returns
 true if any atoms within a given range are selected.
 For example:
\end_layout

\begin_layout LyX-Code
for (int atom = 0; atom < Top.Natom(); ++atom)
\end_layout

\begin_layout LyX-Code
  if (Mask.AtomInCharMask(atom)) 
\end_layout

\begin_layout LyX-Code
    AtomIsSelected(atom);
\end_layout

\begin_layout LyX-Code
for (int res = 0; res < Top.Nres(); ++res)
\end_layout

\begin_layout LyX-Code
  if (Mask.AtomsInCharMask( Top.Res(res).FirstAtom(), Top.Res(re).LastAtom()
 ))
\end_layout

\begin_layout LyX-Code
    ResidueIsSelected(res);
\end_layout

\begin_layout Subsection
DataSet and DataFile
\end_layout

\begin_layout Standard
One of the goals in writing cpptraj was to try and generalize data collection
 and output, so that e.g.
 any action could output in any format known to cpptraj without having to
 write any extra code.
 To that end actions have access to a main DataSetList (named DSL inside
 actions) and DataFileList (named DFL inside actions).
 I will give a simple usage example based on the 'distance' action (Action_Dista
nce, I will actually modify the code that is there slightly to reflect updates
 that will eventually be made).
 The first step is to create the DataSet in the init() routine.
\end_layout

\begin_layout LyX-Code
dist_ = DSL->AddSet(DataSet::DOUBLE, actionArgs.GetStringNext(),"Dis");
\end_layout

\begin_layout LyX-Code
if (dist_==0) return 1;
\end_layout

\begin_layout Standard
In the first line I am adding a DataSet class of type DOUBLE to the master
 DataSetList.
 The various types are enumerated in DataSet.h.
 The DataSet will be named whatever the next string is in the actionArgs
 ArgList.
 If there is no name, a default one will be created based on the given default
 "Dis" and the DataSet's overall position in the DataSetList (so in this
 case the default could be something like Dis_00000).
 What is returned is a pointer to the DataSet; DataSet is actually a base
 class that specific DataSet types inherit (in this case DataSet_double).
 In this way the interface is generalized.
\end_layout

\begin_layout Standard
The next step is to add the DataSet to the DataFileList.
\end_layout

\begin_layout LyX-Code
DFL->AddSetToFile(distanceFile, dist_);
\end_layout

\begin_layout Standard
In this line I am adding DataSet dist_ to a file named distanceFile (string
 obtained previously with something like distanceFile = actionArgs.GetStringKey("
out");).
 If distanceFile is empty the statement has no effect.
 If distanceFile is already in DFL the DataSet will be added to that file
 (in this way output from multiple actions can be combined rather than overwritt
en).
 The machinery of the DataFileList takes care of output from there.
\end_layout

\begin_layout Standard
The final phase is actually adding data to the DataSet.
 So for example in the action() routine you could have:
\end_layout

\begin_layout LyX-Code
double distance = sqrt( DIST2_NoImage( V1, V2 ) );
\end_layout

\begin_layout LyX-Code
dist_->Add(frameNum, &distance);
\end_layout

\begin_layout Standard
In the first line the value 'distance' is being calculated.
 In the next line the value from 'distance' is being added to DataSet dist_
 with frame number 'frameNum' (automatically set within Action).
 Notice that the address of 'distance' is passed rather than the value;
 this is a necessity from the generalization of the DataSet interface.
 DataSet has no idea a prior what the data type might be, so in the Add
 routine the value is cast to what the underlying DataSet implementation
 expects.
 This allows the Add routine to be used for double, float, int, string,
 etc.
 
\end_layout

\begin_layout Part
Adding New Functionality
\end_layout

\begin_layout Standard
Most development for Cpptraj will likely be in adding new functionality;
 actions, analyses, and trajectory/topology/data file formats.
 This part of the manual will provide guidance and some helpful hints to
 this end.
 In general, adding new functionality is done by writing an implementation
 of the desired class type (e.g.
 for actions, inherit from the Action class) and then adding that class
 to the container for that specific functionality (e,g, in the case of actions,
 ActionList).
\end_layout

\begin_layout Section
Adding Actions - Example
\end_layout

\begin_layout Standard
All actions inherit from the Action abstract base class.
 The Action class itself inherits from the DispatchObject class so that
 it can be associated with an allocator (to create the action) and a help
 function.
 There are four functions that every action must implement: Init(), Setup(),
 DoAction(), and Print().
 Init() is called when the action is first created, and processes input
 arguments, sets up DataSets/DataFiles, deals with reference frames, and
 sets the debug level.
 Setup() is called to set the action up for a specific topology, and so
 handles anything Topology-related (such as parsing atom masks).
 The DoAction() function is called to actually perform the action on input
 coordinate frames.
 The Init(), Setup(), and DoAction() functions return a special type of
 integer, Action::RetType, which described the result of the action:
\end_layout

\begin_layout Description
Action::OK Action is successful.
\end_layout

\begin_layout Description
Action::ERR Action is not successful.
\end_layout

\begin_layout Description
Action::USEORIGINALFRAME Action requests that the original unmodified topology/f
rame be used (see e.g.
 Action_Unstrip in Action_Strip.h).
\end_layout

\begin_layout Description
Action::SUPPRESSCOORDOUTPUT Action requests that further processing of the
 current coordinate frame be skipped (see e.g.
 Action_RunningAvg).
\end_layout

\begin_layout Standard
The final function is Print(), which is called after all trajectory processing
 is complete and performs any additional calculation or output necessary.
 This function can be blank if such functionality is not needed, but it
 still must be implemented.
\end_layout

\begin_layout Standard
In addition to Action, there are currently two additional action-related
 classes that actions may want to inherit from.
 The ImagedAction class is for classes that may need to calculate imaged
 distances, and the ActionFrameCounter class is for actions that may want
 to process subsets of input frames (see e.g.
 the Action_Matrix action).
\end_layout

\begin_layout Standard
As an example, we will go through the creation of the Action_Distance class
 for calculating distances; this will cover using the DataSet, DataFile,
 AtomMask, and ImagedAction classes as well.
\end_layout

\begin_layout Subsection
Create the Class Header
\end_layout

\begin_layout Standard
As mentioned in the style guide, header files should be named after the
 class, so the Action_Distance class will go in a file named 
\begin_inset Quotes eld
\end_inset

Action_Distance.h
\begin_inset Quotes erd
\end_inset

.
 The first thing to do is create a 
\begin_inset Quotes eld
\end_inset

header guard
\begin_inset Quotes erd
\end_inset

 - this will prevent issues with multiple inclusion.
 The header guard should be named after the class and header file, so for
 Action_Distance.h:
\end_layout

\begin_layout LyX-Code
#ifndef INC_ACTION_DISTANCE_H
\end_layout

\begin_layout LyX-Code
#define INC_ACTION_DISTANCE_H
\end_layout

\begin_layout Standard
Next comes the class description.
 Since distance calculations may involve imaging we also include the ImagedActio
n class to simplify image handling:
\end_layout

\begin_layout LyX-Code
class Action_Distance: public Action, ImagedAction {
\end_layout

\begin_layout Standard
Following the style guide, we first implement any public methods.
 For actions this is at least the constructor, the allocator (named Alloc()
 by convention), and the Help() function.
 The allocator and help functions need to be static so that they can be
 called without instantiating the class.
 
\end_layout

\begin_layout LyX-Code
public:
\end_layout

\begin_layout LyX-Code
  Action_Distance();  ///< Constructor
\end_layout

\begin_layout LyX-Code
  /// Allocator
\end_layout

\begin_layout LyX-Code
  static DispatchObject* Alloc() { return (DispatchObject*)new Action_Distance()
; }
\end_layout

\begin_layout LyX-Code
  static void Help(); ///< Help function
\end_layout

\begin_layout Standard
The implemented functions Init(), Setup(), DoAction(), and Print() can be
 either public or private, although the preference is private.
\end_layout

\begin_layout Standard
The private section is where all variables specific to the class will go.
 For Action_Distance we will want a DataSet to hold the calculated distances,
 two AtomMasks to describe the points between which the distance should
 be calculated, and a flag to indicate whether the distance should be mass-weigh
ted.
\end_layout

\begin_layout LyX-Code
private:
\end_layout

\begin_layout LyX-Code
  DataSet* dist_;  ///< Will hold DataSet of calculated distances.
\end_layout

\begin_layout LyX-Code
  bool useMass_;   ///< If true, mass-weight distances.
\end_layout

\begin_layout LyX-Code
  AtomMask Mask1_;
\end_layout

\begin_layout LyX-Code
  AtomMask Mask2_;
\end_layout

\begin_layout Standard
All variables related to imaging are already include via the ImagedAction
 class.
 We now add entries for the functions inherited from the Action base class
 which must be implemented.
 Since we will not need to do any post-processing for this action, the Print()
 function is empty:
\end_layout

\begin_layout LyX-Code
  Action::RetType Init(ArgList&, TopologyList*, FrameList*, DataSetList*,
 DataFileList*, int);
\end_layout

\begin_layout LyX-Code
  Action::RetType Setup(Topology*, Topology**);
\end_layout

\begin_layout LyX-Code
  Action::RetType DoAction(int, Frame*, Frame**);
\end_layout

\begin_layout LyX-Code
  void Print() {}
\end_layout

\begin_layout Standard
Last, end the class definition and finish the header guard:
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout LyX-Code
#endif
\end_layout

\begin_layout Subsection
Create the Class Implementation
\end_layout

\begin_layout Standard
Following the naming scheme, the class implementation will go into Action_Distan
ce.cpp.
 The first part of this file will have the necessary #include directives.
 We need <cmath> for the square root function, Action_Distance.h for the
 class definition, and CpptrajStdio.h for wiriting to the console.
 
\end_layout

\begin_layout LyX-Code
#include <cmath>
\end_layout

\begin_layout LyX-Code
#include "Action_Distance.h"
\end_layout

\begin_layout LyX-Code
#include "CpptrajStdio.h"
\end_layout

\begin_layout Standard
First we will need to create the class constructor.
 It is encouraged that users make use of initalizer lists (which tend to
 be more efficient) for this purpose.
 In this case we have two non-class variables: dist_, which is a pointer
 to a DataSet, and useMass_, which is boolean:
\end_layout

\begin_layout LyX-Code
Action_Distance::Action_Distance() : dist_(0), useMass_(true) {}
\end_layout

\begin_layout Standard
Next, ensure that the Help() function has an implementation.
 Note that in cpptraj 
\begin_inset Quotes eld
\end_inset

mprintf
\begin_inset Quotes erd
\end_inset

 is used over 
\begin_inset Quotes eld
\end_inset

printf
\begin_inset Quotes erd
\end_inset

 for making any future IO modifications easier:
\end_layout

\begin_layout LyX-Code
void Action_Distance::Help() {
\end_layout

\begin_layout LyX-Code
  mprintf("distance [<name>] <mask1> <mask2> [out <filename>] [geom] [noimage]
\backslash
n");
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsubsection
Init() - Parse user arguments, set up DataSets/DataFiles etc
\end_layout

\begin_layout Standard
Init() is called when the action is created and is responsible for parsing
 the Argument list (ArgList) and inital setup.
 Init() has the same input arguments for every action:
\end_layout

\begin_layout LyX-Code
Action::RetType Action_Distance::Init(ArgList& actionArgs, TopologyList*
 PFL, FrameList* FL,
\end_layout

\begin_layout LyX-Code
                                      DataSetList* DSL, DataFileList* DFL,
 int debugIn) {
\end_layout

\begin_layout Standard
The input arguments are as follows: actionArgs contains arguments from user
 input, PFL is the current list of Topology classes, FL is the current list
 of reference frames, DSL is the master DataSetList, DFL is the master DataFileL
ist, and debugIn is the current debug level for actions.
 It is up to the action implementation whether it wants to record the debug
 level or not.
\end_layout

\begin_layout Standard
Typical order of argument processing is keywords, masks, DataSet name.
 First we will process the keywords 'noimage', 'geom', and 'out <filename>'.
\end_layout

\begin_layout Standard
In order to determine whether the action will try to use imaging we call
 the InitImaging() function (inherited from the ImagedAction class).
 If the ArgList actionArgs contains the string 
\begin_inset Quotes eld
\end_inset

noimage
\begin_inset Quotes erd
\end_inset

, false will be sent to InitImaging to disable imaging:
\end_layout

\begin_layout LyX-Code
  InitImaging( !(actionArgs.hasKey("noimage")) );
\end_layout

\begin_layout Standard
Next we set useMass_.
 If actionArgs contains the string 
\begin_inset Quotes eld
\end_inset

geom
\begin_inset Quotes erd
\end_inset

, useMass_ will be set to false:
\end_layout

\begin_layout LyX-Code
  useMass_ = !(actionArgs.hasKey("geom"));
\end_layout

\begin_layout Standard
Next, we will try to create an output DataFile:
\end_layout

\begin_layout LyX-Code
  DataFile* outfile = DFL->AddDataFile( actionArgs.GetStringKey("out"), actionArg
s );
\end_layout

\begin_layout Standard
The behavior of AddDataFile() depends on the result from actionArgs.GetStringKey(
); if 
\begin_inset Quotes eld
\end_inset

out
\begin_inset Quotes erd
\end_inset

 is present in actionArgs, the next string (presumably <filename>) is returned
 and passed to AddDataFile(), and a DataFile will be returned corresponding
 to <filename>.
 If 
\begin_inset Quotes eld
\end_inset

out
\begin_inset Quotes erd
\end_inset

 is not present nothing will be returned, no file will be set up, and outfile
 will be null (0).
 
\end_layout

\begin_layout Standard
Next, we will get two atom mask expressions.
 We will require that the user must specify two masks, so if either of the
 strings is empty return an error:
\end_layout

\begin_layout LyX-Code
  std::string mask1 = actionArgs.GetMaskNext();
\end_layout

\begin_layout LyX-Code
  std::string mask2 = actionArgs.GetMaskNext();
\end_layout

\begin_layout LyX-Code
  if (mask1.empty() || mask2.empty()) {
\end_layout

\begin_layout LyX-Code
    mprinterr("Error: distance: Requires 2 masks
\backslash
n");
\end_layout

\begin_layout LyX-Code
    return Action::ERR;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout Standard
Now we can use the mask expression strings to initialize the two AtomMask
 classes (note that this tokenizes the mask expressions but does not yet
 set them up since we need topology information to do that):
\end_layout

\begin_layout LyX-Code
  Mask1_.SetMaskString(mask1);
\end_layout

\begin_layout LyX-Code
  Mask2_.SetMaskString(mask2);
\end_layout

\begin_layout Standard
Next we will use the master DataSetList (DSL) to create a DataSet to store
 the calculated distances.
 We will set up a DataSet of type DOUBLE (for increased precision) using
 any string left in actionArgs, or if no strings are left a default name
 of 
\begin_inset Quotes eld
\end_inset

Dis
\begin_inset Quotes erd
\end_inset

.
 If any errors occur, NULL (0) will be returned:
\end_layout

\begin_layout LyX-Code
  dist_ = DSL->AddSet(DataSet::DOUBLE, actionArgs.GetStringNext(), "Dis");
\end_layout

\begin_layout LyX-Code
  if (dist_==0) return Action::ERR;
\end_layout

\begin_layout Standard
If a DataFile was previously set up, we now add the DataSet to this DataFile:
\end_layout

\begin_layout LyX-Code
  if (outfile != 0) outfile->AddSet( dist_ );
\end_layout

\begin_layout Standard
Last, we print out some information regarding how the Action has been initialize
d and return Action::OK to indicate successful intialization:
\end_layout

\begin_layout LyX-Code
  mprintf("    DISTANCE: %s to %s",Mask1_.MaskString(), Mask2_.MaskString());
\end_layout

\begin_layout LyX-Code
  if (!UseImage())
\end_layout

\begin_layout LyX-Code
    mprintf(", non-imaged");
\end_layout

\begin_layout LyX-Code
  if (useMass_)
\end_layout

\begin_layout LyX-Code
    mprintf(", center of mass");
\end_layout

\begin_layout LyX-Code
  else 
\end_layout

\begin_layout LyX-Code
   mprintf(", geometric center");   mprintf(".
\backslash
n");
\end_layout

\begin_layout LyX-Code
  return Action::OK;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsubsection
Setup() - Set up Topology-related parts of the Action
\end_layout

\begin_layout Standard
Setup() is called whenever the action needs to be set up for a given Topology
 file.
 Any component of the action that depends on Topology (in this case the
 AtomMasks and the Imaging) is handled here.
 The arguments to Setup() are:
\end_layout

\begin_layout LyX-Code
Action::RetType Action_Distance::Setup(Topology* currentParm, Topology**
 parmAddress) {
\end_layout

\begin_layout Standard
Note that both a pointer to the current Topology as well as the address
 of that pointer (Topology**) are given.
 This is for actions that may want to modify the current Topology (see e.g.
 Action_Strip).
 
\end_layout

\begin_layout Standard
IMPORTANT: Note that this is the only time in which a Topology is passed
 to the Action.
 If the Action requires Topology information later (such as in DoAction()
 or Print()) it must be saved in the Action itself (usually through a pointer).
 
\end_layout

\begin_layout Standard
First, we setup the AtomMasks.
 Each AtomMask is passed to the current topology using the SetupIntegerMask()
 function, which will create an integer array containing only the selected
 atoms based on the mask expression.
 If we needed to know both selected and unselected atoms we could use the
 SetupCharMask() function instead.
\end_layout

\begin_layout LyX-Code
  if (currentParm->SetupIntegerMask( Mask1_ )) return Action::ERR;
\end_layout

\begin_layout LyX-Code
  if (currentParm->SetupIntegerMask( Mask2_ )) return Action::ERR;
\end_layout

\begin_layout Standard
After this, we print some information about what atoms are selected (note
 we could also use the MaskInfo() function of AtomMask for this).
 For calculating distance, we need to make sure atoms were actually selected
 (using the None() function of AtomMask):
\end_layout

\begin_layout LyX-Code
  mprintf("
\backslash
t%s (%i atoms) to %s (%i atoms)",Mask1_.MaskString(), Mask1_.Nselected(),
\end_layout

\begin_layout LyX-Code
          Mask2_.MaskString(),Mask2_.Nselected());
\end_layout

\begin_layout LyX-Code
  if (Mask1_.None() || Mask2_.None()) {
\end_layout

\begin_layout LyX-Code
    mprintf("
\backslash
nWarning: distance: One or both masks have no atoms.
\backslash
n");
\end_layout

\begin_layout LyX-Code
    return Action::ERR;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout Standard
Next we determine if imaging can actually be performed based on the box
 information present in the current Topology; if there is no box information
 imaging cannot be performed.
 We do this with the SetupImaging() function, inherited from ImagedAction.
 The ImagingEnabled() function (also inherited from ImagedAction) will let
 us know if imaging for this Topology is possible or not:
\end_layout

\begin_layout LyX-Code
SetupImaging( currentParm->BoxType() );
\end_layout

\begin_layout LyX-Code
  if (ImagingEnabled())
\end_layout

\begin_layout LyX-Code
    mprintf(", imaged");
\end_layout

\begin_layout LyX-Code
  else
\end_layout

\begin_layout LyX-Code
    mprintf(", imaging off");
\end_layout

\begin_layout LyX-Code
  mprintf(".
\backslash
n");
\end_layout

\begin_layout Standard
Now all Topology-dependent aspects of the action are set up.
 Return Action::OK.
\end_layout

\begin_layout LyX-Code
  return Action::OK;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsubsection
DoAction() - Process input Frame
\end_layout

\begin_layout Standard
Coordinates are read in a frame at a time and stored in a Frame class, which
 is then passed to each action in the ActionList.
 The DoAction() function is called to process a coordinate Frame.
 The arguments are:
\end_layout

\begin_layout LyX-Code
Action::RetType Action_Distance::DoAction(int frameNum, Frame* currentFrame,
 Frame** frameAddress) {
\end_layout

\begin_layout Standard
The first argument is the current frame number (starting at 0).
 Note that like Setup(), both a pointer to the current Frame as well as
 the address of that pointer (Frame**) are given, again so that actions
 may modify the current Frame (see e.g.
 Action_Strip).
\end_layout

\begin_layout Standard
There are several variables needed for calculating the distance.
 First, we have two Vec3 classes to store the XYZ coordinates of the points:
\end_layout

\begin_layout LyX-Code
  Vec3 a1, a2;
\end_layout

\begin_layout Standard
If we are performing non-orthorhombic imaging we need to store unit cell
 and reciprocal XYZ vector coordinates (in Matrix_3x3 classes):
\end_layout

\begin_layout LyX-Code
  Matrix_3x3 ucell, recip;
\end_layout

\begin_layout Standard
Finally, we need a double to store the actual result of the distance calculation
:
\end_layout

\begin_layout LyX-Code
  double Dist;
\end_layout

\begin_layout Standard
In the first part of the actual calculation, we calculate the centers of
 the coordinates in Mask1_ and Mask2_, either mass-weighted or not depending
 on useMass_:
\end_layout

\begin_layout LyX-Code
  if (useMass_) {
\end_layout

\begin_layout LyX-Code
    a1 = currentFrame->VCenterOfMass( Mask1_ );
\end_layout

\begin_layout LyX-Code
    a2 = currentFrame->VCenterOfMass( Mask2_ );
\end_layout

\begin_layout LyX-Code
  } else {
\end_layout

\begin_layout LyX-Code
    a1 = currentFrame->VGeometricCenter( Mask1_ );
\end_layout

\begin_layout LyX-Code
    a2 = currentFrame->VGeometricCenter( Mask2_ );
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout Standard
Next, we get the distance between the coordinates stored in a1 and a2.
 For non-orthorhombic imaging we first need to convert the current box coordinat
e vectors (given as 3 lengths and 3 angles) into unit cell and reciprocal
 space coordinates:
\end_layout

\begin_layout LyX-Code
  switch ( ImageType() ) {
\end_layout

\begin_layout LyX-Code
    case NONORTHO:
\end_layout

\begin_layout LyX-Code
      currentFrame->BoxCrd().ToRecip(ucell, recip);
\end_layout

\begin_layout LyX-Code
      Dist = DIST2_ImageNonOrtho(a1, a2, ucell, recip);
\end_layout

\begin_layout LyX-Code
      break;
\end_layout

\begin_layout LyX-Code
    case ORTHO:
\end_layout

\begin_layout LyX-Code
      Dist = DIST2_ImageOrtho(a1, a2, currentFrame->BoxCrd());
\end_layout

\begin_layout LyX-Code
      break;
\end_layout

\begin_layout LyX-Code
    case NOIMAGE:
\end_layout

\begin_layout LyX-Code
      Dist = DIST2_NoImage(a1, a2);       break;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  Dist = sqrt(Dist);
\end_layout

\begin_layout Standard
Last, we add the result to the DataSet and return Action::OK.
 Since DataSet is just an interface we pass in the address of Dist (&Dist)
 to let the underlying DataSet framework take care of the fact that it is
 a double.
\end_layout

\begin_layout LyX-Code
  dist_->Add(frameNum, &Dist);
\end_layout

\begin_layout LyX-Code
  return Action::OK;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection
Add the Action to the Command class
\end_layout

\begin_layout Standard
Now that the class implementation is complete, we need to let cpptraj know
 how to call it.
 This is currently done using a static array in Command.cpp called Commands.
 An entry in Commands is called a DispatchToken (DispatchObject.h) and consists
 of 5 fields:
\end_layout

\begin_layout Enumerate
Type: The DispatchType, in this case DispatchObject::ACTION.
\end_layout

\begin_layout Enumerate
Cmd: The keyword (const character string) that will call this action.
\end_layout

\begin_layout Enumerate
Alloc: The Allocator, which we previously defined in the header as Alloc().
\end_layout

\begin_layout Enumerate
Help: The help function, which we defined in the header and implemented
 as a static void function.
\end_layout

\begin_layout Enumerate
Idx: This is currently unused for actions and can be set to zero.
\end_layout

\begin_layout Standard
To make navigation of Commands.cpp easier, you can search for INC_ACTION
 (or INC_ANALYSIS if adding an Analysis) to go where things need to be added.
 First add the class to Commands.cpp with the appropriate '#include'.
\end_layout

\begin_layout LyX-Code
#include "Action_Dihedral.h"
\end_layout

\begin_layout LyX-Code
#include "Action_Distance.h"
\end_layout

\begin_layout LyX-Code
#include "Action_Hbond.h"
\end_layout

\begin_layout Standard
Then will add the command entry to commands in the appropriate section (in
 this case DispatchObject::ACTION) alphabetically by keyword.
 The final array can look like e.g.:
\end_layout

\begin_layout LyX-Code
const DispatchObject::Token Command::Commands[] = {
\end_layout

\begin_layout LyX-Code
  { DispatchObject::ACTION, "dihedral", Action_Dihedral::Alloc, Action_Dihedral:
:Help, 0 },
\end_layout

\begin_layout LyX-Code
  { DispatchObject::ACTION, "distance", Action_Distance::Alloc, Action_Distance:
:Help, 0 },
\end_layout

\begin_layout LyX-Code
  { DispatchObject::ACTION, "hbond", Action_Hbond::Alloc, Action_Hbond::Help,
 0 },
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Part
Overall Code Organization
\begin_inset CommandInset label
LatexCommand label
name "part:Overall-Code-Organization"

\end_inset


\end_layout

\begin_layout Standard

\series bold
WARNING: MUCH OF THE INFORMATION IN THIS SECTION IS OUT-OF-DATE AS OF 2013-01-23.
 REFER TO INTERNAL CODE DOCUMENTATION FOR NOW.
\end_layout

\begin_layout Section
Classes
\end_layout

\begin_layout Subsection
Cpptraj
\begin_inset CommandInset label
LatexCommand label
name "sec:Cpptraj"

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
Cpptraj
\emph default
 class is the main class in cpptraj.
 It is responsible for interfacing with the user and redirecting commands
 to their appropriate classes.
 It contains all relevant data and controls the flow of the program.
 Data in cpptraj can be divided into 8 categories, listed below.
 Each item is listed with the following format with the class name that
 defines the list and the name of the list instance defined in the main
 Cpptraj class.
 The various classes that define the data structures listed below are described
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:FileList"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:ActionList"

\end_inset


\end_layout

\begin_layout Description
TopologyList
\begin_inset space ~
\end_inset

parmFileList List of all Topology classes from loaded topology files.
\end_layout

\begin_layout Description
TrajinList
\begin_inset space ~
\end_inset

trajinList List of all Trajin classes whose frames will be read in and passed
 to each action during coordinate processing.
\end_layout

\begin_layout Description
FrameList
\begin_inset space ~
\end_inset

refFrames List of ReferenceFrame classes containing reference coordiantes.
\end_layout

\begin_layout Description
TrajoutList
\begin_inset space ~
\end_inset

trajoutList List of all Trajout classes that will be written to during coordinat
e processing.
\end_layout

\begin_layout Description
AnalysisList
\begin_inset space ~
\end_inset

analysisList List of all Analysis classes, which will be performed after
 coordinate processing.
\end_layout

\begin_layout Description
DataSetList
\begin_inset space ~
\end_inset

DSL
\begin_inset CommandInset label
LatexCommand label
name "Master_DSL"

\end_inset

 List of all DataSet classes generated by various actions/analyses.
\end_layout

\begin_layout Description
ActionList
\begin_inset space ~
\end_inset

actionList List of all Action classes to be performed during coordinate
 processing.
\end_layout

\begin_layout Description
DataFileList
\begin_inset space ~
\end_inset

DFL List of all DataFile classes that will write data from one or more DataSets.
\end_layout

\begin_layout Standard
The Cpptraj class is set up via calls to AddParm() (which adds a new Topology),
 SetGlobalDebug() (which sets the overall debug level), and Dispatch(),
 which handles all commands.
 Once Cpptraj is set up the Run() routine executes the program.
 Run() is separated into five phases: Setup, Action, Action Output, Analysis,
 and Data Write.
 Setup prepares trajectory files for reading and actions for processing.
 Action runs through all input trajectories and peforms all actions on each
 frame read in.
 Action output performs all action output that lies outside normal data
 file writing, as well as any post-processing needed by actions.
 The analysis phase performs analysis on data generated by the action phase.
 Finally, the Data Write phase writes data out in a specified format.
\end_layout

\begin_layout Subsection
FileList
\begin_inset Index idx
status open

\begin_layout Plain Layout
FileList
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sec:FileList"

\end_inset


\end_layout

\begin_layout Standard
All file lists except for the 
\emph on
TrajinList
\emph default
 is handled by classes derived from 
\emph on
FileList
\emph default
.
 
\emph on
FileList
\emph default
 provides the machinery to store file names via a `base' name or a full
 file name, and to apply tags to various file names, as well as providing
 the machinery to look up files based on given criteria.
\end_layout

\begin_layout Subsection
DataFileList
\begin_inset Index idx
status open

\begin_layout Plain Layout
DataFileList
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This stores the list of output 
\emph on
DataFile
\emph default
 objects (it actually stores the pointers) that cpptraj will write after
 all of the data sets are generated and analyzed.
 To add to this list, you must add a data set along with the file name the
 data set is to be printed in.
 If the file name does not exist, a new DataFile object will be created
 and added to the list with that data set as the first data set to be printed.
\end_layout

\begin_layout Subsection
FrameList
\begin_inset Index idx
status open

\begin_layout Plain Layout
FrameList
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This stores a list of 
\emph on
Frame
\emph default
 pointers that can be looked up by file name or index (although not all
 frames need come from a unique file).
\end_layout

\begin_layout Subsection
TopologyList
\begin_inset Index idx
status open

\begin_layout Plain Layout
TopologyList
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This stores the list of topology files that are loaded into cpptraj as a
 list of 
\emph on
Topology
\emph default
 pointers.
 This pertains cpptraj's ability to analyze trajectories from multiple topology
 files.
 Topology files should be added to the master topology file list via the
 class function 
\emph on
AddParmFile
\emph default
.
 If another TopologyList is set up to contain copies of topology object
 pointers (such as the 
\emph on
TopologyList
\emph default
 for the reference frames), topology files should be added via the 
\emph on
AddParm
\emph default
 function.
 
\emph on
AddParmFile
\emph default
 and 
\emph on
AddParm
\emph default
 should never be used by the same 
\emph on
TopologyList
\emph default
.
\end_layout

\begin_layout Subsection
TrajoutList
\begin_inset Index idx
status open

\begin_layout Plain Layout
TrajoutList
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This stores the list of pointers to output trajectory files that need to
 be written.
 This list is appended to every time a ``trajout'' command is encountered
 in the input stream.
\end_layout

\begin_layout Subsection
TrajinList
\begin_inset Index idx
status open

\begin_layout Plain Layout
TrajinList
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This stores the list of pointers to input trajectories and sets them up
 to be read and processed frame by frame.
 Because this list does not need the machinery provided by the 
\emph on
FileList
\emph default
 base class, it does 
\emph on
not
\emph default
 inherit from it.
\end_layout

\begin_layout Subsection
ActionList
\begin_inset Index idx
status open

\begin_layout Plain Layout
ActionList
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sec:ActionList"

\end_inset


\end_layout

\begin_layout Standard
An action is defined as an operation that will take place on specified frames
 of input trajectories.
 
\emph on
Action
\emph default
 instances are stored in the 
\emph on
ActionList
\emph default
 class.
 During trajectory reads, each frame that is read is passed to the action
 list to be processed.
 The 
\emph on
ActionList
\emph default
 has the power to modify the current parm and/or frame.
\end_layout

\begin_layout Standard
The 
\emph on
AddAction
\emph default
 attribute takes an argument list for the command and generates a new Action
 pointer that is added to the 
\emph on
ActionList
\emph default
 queue.
 Therefore, when implementing new 
\emph on
Action
\emph default
s, the 
\emph on
ActionList::AddAction
\emph default
 function must be modified to properly instantiate the new 
\emph on
Action
\emph default
.
 Every frame is passed through the 
\emph on
ActionList
\emph default
, which is sent through every action before being given to the 
\emph on
TrajoutList
\emph default
.
\end_layout

\begin_layout Subsection
DataSetList
\begin_inset Index idx
status open

\begin_layout Plain Layout
DataSetList
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This class contains a list of pointers to 
\emph on
DataSet
\emph default
 classes.
 The master 
\emph on
DataSetList
\emph default
 (described 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "Master_DSL"

\end_inset

) has data sets added to this list via the 
\emph on
AddSet
\emph default
, 
\emph on
AddSetIdx
\emph default
, 
\emph on
AddSetAspect
\emph default
, 
\emph on
AddDataSet
\emph default
, and 
\emph on
AddSetIdxAspect
\emph default
 methods of 
\emph on
DataSetList
\emph default
.
 These methods will instantiate a new 
\emph on
DataSet
\emph default
 object and store its pointer inside internal data structures.
 All other instances of 
\emph on
DataSetList
\emph default
s that are used to track existing data sets should track copies of 
\emph on
DataSet
\emph default
s via the 
\emph on
AddCopyOfSet
\emph default
 method of 
\emph on
DataSetList
\emph default
.
 You must use either 
\emph on
AddCopyOfSet
\emph default
 exclusively to populate a 
\emph on
DataSetList
\emph default
, or any other method except 
\emph on
AddCopyOfSet
\emph default
 exclusively to populate a 
\emph on
DataSetList
\emph default
.
\end_layout

\begin_layout Subsection
AnalysisList
\begin_inset Index idx
status open

\begin_layout Plain Layout
AnalysisList
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This class contains a list of pointers to 
\emph on
Analysis
\emph default
 classes.
 Analyses are analogous to Actions, except instead of acting on 
\emph on
Frame
\emph default
s, they act on 
\emph on
DataSet
\emph default
s.
\end_layout

\begin_layout Section
Basic File Handling
\end_layout

\begin_layout Standard
Basic file handling in Cpptraj is done by several classes.
 The 
\emph on
FileIO
\emph default
 abstract base class handles the interface for basic file input/output operation
s for a given file type (currently standard, gzip, bzip2, or MPI).
 Every type of file that requires a unique set of input/output functions
 should be assigned its own class that inherits from 
\emph on
FileIO
\emph default
.
 For example, 
\emph on
FileIO_Std
\emph default
 is an uncompressed file whose I/O is handled by standard C file operations
 like 
\emph on
fopen
\emph default
(), 
\emph on
fread
\emph default
(), 
\emph on
fgets
\emph default
(), and so on.
 
\emph on
FileIO_Gzip
\emph default
, on the other hand, is a GZIP-compressed file whose I/O is handled by calls
 to the GZIP C-API (included through 
\family typewriter
zlib.h
\family default
) such as 
\emph on
gzopen
\emph default
(), 
\emph on
gzread
\emph default
(), 
\emph on
gzwrite
\emph default
(), and so on.
 The 
\emph on
FileIO
\emph default
 class is described in more detail in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:FileIO"

\end_inset

.
\end_layout

\begin_layout Standard
The 
\emph on
CpptrajFile
\emph default
 class is the base class for all File type objects.
 These classes provide functions that allow you to open a file object for
 reading or writing, but more importantly tracks whether a file is compressed
 or not, allows parallel writes of standard text files with MPI, and dissects
 the file name to give easy access to file name extensions (i.e., the characters
 that come after the last period in the file name), base names (i.e., the
 name of the file with extension, but no path information) and the full
 file name (base name complete with file system location).
 The 
\emph on
CpptrajFile
\emph default
 class is described in more detail in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:CpptrajFile"

\end_inset

.
 Every 
\emph on
CpptrajFile
\emph default
 (and derived class) instances contain a 
\emph on
FileIO
\emph default
-derived instance named 
\emph on
IO
\emph default
 that is responsible for direct interaction with the open file.
 
\end_layout

\begin_layout Subsection
FileIO
\begin_inset Index idx
status open

\begin_layout Plain Layout
FileIO
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sec:FileIO"

\end_inset


\end_layout

\begin_layout Standard
A
\emph on
 FileIO
\emph default
 instance will be contained inside the File wrapper classes (e.g., TrajectoryFile
 and DataFile, described above), which will hold a pointer to a FileIO object
 that will be assigned based on the file type, e.g.:
\end_layout

\begin_layout LyX-Code
FileIO* IO = new FileIO_Gzip();
\end_layout

\begin_layout Standard
where 
\emph on
FileIO_Gzip
\emph default
 is a class that inherits 
\emph on
FileIO
\emph default
.
 
\emph on
FileIO
\emph default
 contains several virtual members that all inheriting file type classes
 must implement (in fact, all 
\emph on
FileIO
\emph default
 functions are virtual!).
\end_layout

\begin_layout Subsection*
Inheritable Functions
\end_layout

\begin_layout Description
virtual
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

Open(const
\begin_inset space ~
\end_inset

char
\begin_inset space ~
\end_inset

*filename,
\begin_inset space ~
\end_inset

const
\begin_inset space ~
\end_inset

char
\begin_inset space ~
\end_inset

*mode) Open the file <filename> with the specified mode.
\end_layout

\begin_layout Description
virtual
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

Close() Closes the file.
\end_layout

\begin_layout Description
virtual
\begin_inset space ~
\end_inset

off_t
\begin_inset space ~
\end_inset

Size(const
\begin_inset space ~
\end_inset

char
\begin_inset space ~
\end_inset

*filename) 
\shape italic
[Optional: Needed for Compressed Only]
\shape default
 Return the uncompressed size of the file.
 
\end_layout

\begin_layout Description
virtual
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

Read(void
\begin_inset space ~
\end_inset

*buffer,
\begin_inset space ~
\end_inset

size_t
\begin_inset space ~
\end_inset

size) Read size bytes from a file into buffer.
\end_layout

\begin_layout Description
virtual
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

Write(void
\begin_inset space ~
\end_inset

*buffer,
\begin_inset space ~
\end_inset

size_t
\begin_inset space ~
\end_inset

size) Write size bytes from buffer to a file.
\end_layout

\begin_layout Description
virtual
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

Seek(off_t
\begin_inset space ~
\end_inset

position) Move the file pointer to a specific position in the stream.
 The offset is always considered to be SEEK_SET.
\end_layout

\begin_layout Description
virtual
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

Rewind() Reset the file pointer.
 In cases where rewind is not supported the file will be closed and reopened.
\end_layout

\begin_layout Description
virutal
\begin_inset space ~
\end_inset

off_t
\begin_inset space ~
\end_inset

Tell() 
\shape italic
[Optional for now: Currently not used by any function in Cpptraj]
\shape default
 Return the position of the file pointer.
 
\end_layout

\begin_layout Description
virtual
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

Gets(char
\begin_inset space ~
\end_inset

*buffer,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

length) Read length bytes into buffer, up until newline, null, or EOF.
\end_layout

\begin_layout Subsection
CpptrajFile
\begin_inset Index idx
status open

\begin_layout Plain Layout
CpptrajFile
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sec:CpptrajFile"

\end_inset


\end_layout

\begin_layout Standard
A CpptrajFile is has both a Type and an Access Type (defined by enumerated
 types 
\emph on
FileType
\emph default
 and 
\emph on
AccessType
\emph default
 respectively in 
\family typewriter
CpptrajFile.h
\family default
).
 The enumerated type 
\emph on
FileType
\emph default
 is used to identify what the underlying 
\emph on
FileIO
\emph default
 object is (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:FileIO"

\end_inset

 for details).
 Each time a new 
\emph on
FileIO
\emph default
-derived class is added, another member should be added to 
\emph on
FileType
\emph default
.
 See 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Cpptraj-File-Types"

\end_inset

 for a list of currently recognized file types.
 Note, each file type enumerated here has a corresponding partner in 
\emph on
FileTypeName
\emph default
 which must be modified along with 
\emph on
FileType
\emph default
 if another type is added.
\end_layout

\begin_layout Standard
The access type declares whether the file is opened for reading, writing,
 or appending, denoted by the members READ, WRITE, and APPEND in the enumerated
 type 
\emph on
AccessType
\emph default
.
 Note, each access type enumerated here has a corresponding partner in 
\emph on
AccessTypeName
\emph default
 which must be modified along with 
\emph on
AccessType
\emph default
 if another type of access is added (this is highly unlikely, though).
\end_layout

\begin_layout Standard
There are three main, generic base classes for all Cpptraj file objects---
\emph on
TrajectoryIO
\emph default
, 
\emph on
DataIO
\emph default
, and 
\emph on
ParmIO
\emph default
---each described below.
 Each one follows a similar trend in that each of these classes has a wrapper
 class (described alongside them) that is responsible for abstracting the
 implementation details of each specific type of trajectory, data format,
 or parm format.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Cpptraj-File-Types"

\end_inset

Cpptraj File Types
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FileType
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UNKNOWN_TYPE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
File type is unknown.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
STANDARD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Normal uncompressed file.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GZIPFILE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Gzipped file.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BZIP2FILE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bzip2-ed file.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ZIPFILE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zipped file, currently not implemented.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MPIFILE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Normal file handled in Parallel.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
TrajectoryIO
\begin_inset Index idx
status open

\begin_layout Plain Layout
TrajectoryIO
\end_layout

\end_inset

 and TrajectoryFile
\begin_inset Index idx
status open

\begin_layout Plain Layout
TrajectoryFile
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Trajectory files comprise a subset of file formats, and are handled by a
 combination of the 
\emph on
TrajectoryFile
\emph default
 class, which deals with the common features of trajectories (number of
 frames, start frame, stop frame, etc), and a TrajectoryIO class, which
 handles all IO operations for the trajectory.
 The 
\emph on
TrajectoryIO
\emph default
 class is a base class which should be inherited by any class implementing
 trajectory IO operations.
\end_layout

\begin_layout Standard

\emph on
TrajectoryFile
\emph default
 is the main class used for handling trajectory files.
 The intent is for 
\emph on
TrajectoryFile
\emph default
 to be an easy-to-use class for reading and writing any trajectory format
 that Cpptraj recognizes.
 
\emph on
TrajectoryFile
\emph default
 will contain information common to all trajectory formats, as well as a
 
\emph on
TrajectoryIO
\emph default
 class that will be used for reading/writing that specific format.
\end_layout

\begin_layout Standard
The 
\emph on
TrajectoryIO
\emph default
 class is a base class for all trajectory file formats (some trajectory
 classes inherit from other file type classes as well, such as 
\emph on
FrameBuffer
\emph default
 for 
\emph on
Traj_AmberRestart
\emph default
 and 
\emph on
Traj_AmberCoord
\emph default
).
 The 
\emph on
TrajectoryFile
\emph default
 class is a wrapper around the 
\emph on
TrajectoryIO
\emph default
 classes that hides implementation details.
 You should not interact directly with 
\emph on
TrajectoryIO
\emph default
 objects, but rather interact with them through a 
\emph on
TrajectoryFile
\emph default
, as described more thoroughly in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "part:TrajectoryFile"

\end_inset

.
\end_layout

\begin_layout Standard

\emph on
TrajectoryFile
\emph default
 has an enumerated type listing the different available trajectory formats.
 Every format (i.e., class that derives from 
\emph on
TrajectoryIO
\emph default
) needs a value in the enumerated type 
\emph on
TrajFormatType
\emph default
 and a label in 
\emph on
FORMAT_STRINGS
\emph default
.
 The currently available 
\emph on
TrajFormatType
\emph default
 enumerated values are listed and described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Cpptraj-TrajFile-Formats."

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Cpptraj-TrajFile-Formats."

\end_inset

Cpptraj File Formats.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
TrajFormatType
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UKNOWN_FORMAT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Format is unknown.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AMBERNETCDF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Amber NetCDF trajectory file.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AMBERRESTARTNC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Amber NetCDF restart file
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PDBFILE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PDB File
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MOL2FILE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TRIPOS Mol2 file
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CHARMMDCD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CHARMM (and NAMD) Dcd Binary Trajectory file
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BINPOS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Scripps binary Binpos Trajectory File
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AMBERRESTART
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Amber ASCII Restart file
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CONFLIB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Experimental: conflib.dat file from NAB Lmod output.
 Detection is based on filename.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NTRAJ
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No (NULL) Trajectory file.
 This should always be the last enumerated trajectory type.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The intent has been to make 
\emph on
TrajectoryIO
\emph default
 as independent as possible from classes that implement specific formats.
 Therefore, it does not store any parameter information.
 When parameter information is needed, a 
\emph on
Topology
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Topology
\end_layout

\end_inset

 pointer (which is independent of all parm formats, see below) is passed
 in.
 
\end_layout

\begin_layout Standard
All trajectory formats should inherit from 
\emph on
TrajectoryIO
\emph default
 and implement the following virtual functions:
\end_layout

\begin_layout Description
bool
\begin_inset space ~
\end_inset

ID_TrajFormat(): Checks for a tell-tale sign that this file is in fact the
 trajectory file whose format is designated by your class.
 Return 
\family typewriter
true
\family default
 if this is a recognized format and 
\family typewriter
false
\family default
 if it is not recognized.
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

setupTrajin(Topology
\begin_inset space ~
\end_inset

*trajparm): Called inside 
\emph on
TrajectoryFile::SetupRead
\emph default
.
 Takes as an argument the Topology class that will be associated with this
 trajectory.
 Returns the number of frames in the underlying trajectory file.
 Should set all variables (title, seekable, hasBox, boxAngle (only if hasBox),
 hasTemperature, and hasVelocity).
 If an error occurs should return -1.
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

setupTrajout(Topology
\begin_inset space ~
\end_inset

*trajparm,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

Nframes) Called inside 
\emph on
TrajectoryFile::WriteFrame
\emph default
 on the first write call.
 Takes as an argument the 
\emph on
Topology
\emph default
 class that will be associated with this trajectory and the total number
 of frames that will be written to this trajectory file.
 Should return 0 for success, 1 for error.
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

openTraj() Prepare trajectory for read/write.
 If successful, return 0.
 Otherwise return 1.
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

closeTraj() Finish trajectory and close the file handle
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

readFrame(int
\begin_inset space ~
\end_inset

set,
\begin_inset space ~
\end_inset

double
\begin_inset space ~
\end_inset

*X,
\begin_inset space ~
\end_inset

double
\begin_inset space ~
\end_inset

*V,
\begin_inset space ~
\end_inset

double
\begin_inset space ~
\end_inset

*box,
\begin_inset space ~
\end_inset

double
\begin_inset space ~
\end_inset

*T) Given a frame number (set), read that frame; return the coordinates
 in the first array, velocities in the second array, the box lengths/angles
 in the third array, and set the temperature in the last var.
 Return 0 for success, 1 for failure.
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

writeFrame(int
\begin_inset space ~
\end_inset

set,
\begin_inset space ~
\end_inset

double
\begin_inset space ~
\end_inset

*X,
\begin_inset space ~
\end_inset

double
\begin_inset space ~
\end_inset

*V,
\begin_inset space ~
\end_inset

double
\begin_inset space ~
\end_inset

*box,
\begin_inset space ~
\end_inset

double
\begin_inset space ~
\end_inset

T) Write to output trajectory.
 This routine is called from 
\emph on
TrajectoryFile::WriteFrame
\emph default
 with the current action set number, not the current output number, so it
 is up to the 
\emph on
TrajectoryIO
\emph default
 object to keep track of what frame it is writing.
 Vars are same as in readFrame above.
 Return 0 for success, 1 for failure.
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

info() Print information on what kind of trajectory this is to stdout.
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

processWriteArgs() (Optional) Process any arguments from the arg list that
 have to do with setting the trajectory up for writing.
 It is desireable that any changes made to the TrajectoryIO object from
 within this function are implemented as functions that can be called independen
tly if need be (e.g.
 setting the write mode for PDB files).
\end_layout

\begin_layout Subsection
DataIO
\begin_inset Index idx
status open

\begin_layout Plain Layout
DataIO
\end_layout

\end_inset

 and DataFile
\begin_inset Index idx
status open

\begin_layout Plain Layout
DataFile
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
DataIO
\emph default
 class is a base class for all data file formats.
 This provides an easy mechanism for changing the data file output to match
 various programs (e.g., 
\emph on
gnuplot
\emph default
 or 
\emph on
grace
\emph default
).
 The 
\emph on
DataFile
\emph default
 class is a wrapper around the 
\emph on
DataIO
\emph default
 classes that hides implementation details for each data file type from
 you.
 You should interact with 
\emph on
DataIO
\emph default
 objects through 
\emph on
DataFile
\emph default
 handlers.
\end_layout

\begin_layout Standard
Each 
\emph on
DataIO
\emph default
 class inherits the functionality to write as well as read data files in
 that format, which enhances Cpptraj's flexibility to analyze data sets
 (even in existing data files).
 The current data file format options are summarized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tbl:data_file_formats"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Data file formats and 
\emph on
DataIO
\emph default
 subclasses
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DataIO Subclass
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DataIO_Gnuplot
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Gnuplot-formatted data file
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DataIO_Grace
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Grace (xmgrace)-formatted data file
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DataIO_Std
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Standard output file format, similar to ptraj-style output
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tbl:data_file_formats"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
ParmIO
\begin_inset Index idx
status open

\begin_layout Plain Layout
ParmIO
\end_layout

\end_inset

 and ParmFile
\begin_inset Index idx
status open

\begin_layout Plain Layout
ParmFile
\end_layout

\end_inset

 and Topology
\begin_inset Index idx
status open

\begin_layout Plain Layout
Topology
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
ParmIO
\emph default
 class is a base class for all topology file formats.
 This provides an easy mechanism for extracting the system topology from
 any number of file formats.
 The 
\emph on
ParmFile
\emph default
 class is a wrapper around the 
\emph on
ParmIO
\emph default
 classes that hides the implementation details for each data file type from
 you.
 You should interact with 
\emph on
ParmIO
\emph default
 objects through 
\emph on
ParmFile
\emph default
 handlers.
 
\emph on
ParmFile
\emph default
 provides the ability to both read and write topology file objects of any
 class.
\end_layout

\begin_layout Standard
One thing that sets 
\emph on
ParmIO
\emph default
 and 
\emph on
ParmFile
\emph default
 apart from 
\emph on
TrajectoryIO/TrajectoryFile
\emph default
 and 
\emph on
DataIO/DataFile
\emph default
 is its connection with the 
\emph on
Topology
\emph default
 class.
 
\emph on
Topology
\emph default
 objects contain as much of the information in the Amber topology file as
 can be parsed from the information present in the ParmIO object (and figured
 out based on atomic arrangements).
 A 
\emph on
Topology
\emph default
 instance is the first argument passed to the 
\emph on
ParmFile::Read
\emph default
 function, followed by the name of the topology file.
 Unlike the 
\emph on
DataFile
\emph default
 and 
\emph on
TrajectoryFile
\emph default
 classes, 
\emph on
ParmFile
\emph default
 does not have a reference to the 
\emph on
ParmIO
\emph default
 object to forward read/write information to.
 It exists simply to fill the 
\emph on
Topology
\emph default
 class with the relevant data structures and inform it how to do the rest.
 The 
\emph on
Topology
\emph default
 class is format-independent, providing a layer of abstraction to make other
 parts of the code that require topology information less error-prone while
 coding.
\end_layout

\begin_layout Standard
Every 
\emph on
ParmIO
\emph default
 subclass implements a 
\emph on
ReadParm
\emph default
 method that takes a 
\emph on
Topology
\emph default
 instance as the first argument and fills as much of the information there
 as possible.
 Afterwards, the CommonSetup method of the Topology class is called to finish
 setup and determine bond information (from atom distances if not present
 directly in the file format) and molecule information (based on the bonded
 structure).
 The currently available types of topologies are summarized in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tbl:Cpptraj-Parm-Formats"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Topology file formats currently implemented in Cpptraj.
 The first column has the 
\emph on
ParmIO
\emph default
 class name as well as the 
\emph on
ParmFormatType
\emph default
 enumeration type that corresponds to that class inside 
\emph on
ParmFile
\emph default
 in parentheses.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
ParmIO
\emph default
 Subclass (
\emph on
ParmFormatType
\emph default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parm_Amber (AMBERPARM)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Amber style topology file (OLD and NEW styles)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parm_CharmmPsf (CHARMMPSF)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CHARMM PSF topology file format (used by NAMD, too)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parm_Mol2 (MOL2FILE)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TRIPOS Mol2 file
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parm_PDB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PDB File
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tbl:Cpptraj-Parm-Formats"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Several variables in 
\emph on
Topology
\emph default
 relate to solvent information:
\end_layout

\begin_layout Description
finalSoluteRes_: IPTRES in sander.
 Residue number of the final residue of solute, starts from 1.
 Read in from the SOLVENT_POINTERS section of a parmtop if IFBOX > 0.
\begin_inset Newline newline
\end_inset

Used in Action_DSSP.cpp, Action_Jcoupling.cpp, and Action_Rmsd.cpp when automatical
ly determining what residues to perform calculations on.
\end_layout

\begin_layout Description
molecules_: std::vector of Molecule instances.
 The ATOMS_PER_MOLECULE and NSPM pointers can be set from the information
 in here.
\begin_inset Newline newline
\end_inset

Used in Action_Image.cpp when imaging by molecule.
\end_layout

\begin_layout Description
atomsPerMol: NSP(NSPM) in sander.
 Integer array of size 
\series bold
molecules
\series default
 holding the number of atoms in each molecule.
 Read in from the ATOMS_PER_MOLECULE section of a parmtop if IFBOX > 0.
 
\begin_inset Newline newline
\end_inset

Used in Traj_PDBfile.cpp to determine where TER cards should be output, and
 in Action_Image.cpp to determine imaging by molecule.
\end_layout

\begin_layout Description
NSolventMolecules_: The number of solvent molecules.
\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\end_body
\end_document
